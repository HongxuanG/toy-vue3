# ğŸš€ reactive & effect ä¸”åˆ©ç”¨Jestæµ‹è¯•å®ç°æ•°æ®å“åº”å¼ï¼ˆäºŒï¼‰

## å‰è¨€
ä¸Šä¸€ç¯‡è®²äº†reactiveå’Œeffectæ•°æ®å“åº”çš„åŸºæœ¬åŸç†ï¼Œè¿™ç¯‡æ‰“ç®—è®²effectçš„å…¶ä»–ç”¨æ³•ï¼Œeffectçš„ç¬¬äºŒä¸ªå½¢å‚optionçš„å®ç°ï¼Œå†…å®¹åŒ…æ‹¬ `runner`ï¼Œ`scheduler`ï¼Œ`stop`ï¼ˆåˆ é™¤ä¾èµ–ï¼‰å’Œ`onStop`ï¼ˆä¾èµ–åˆ é™¤åçš„å›è°ƒï¼‰ã€‚
## å®ç°runneræ‰‹åŠ¨è§¦å‘ä¾èµ–
runnerå…¶å®å°±æ˜¯ReactiveEffectå®ä¾‹å¯¹è±¡çš„run()å‡½æ•°çš„å‡½æ•°ä½“ï¼Œeffectä¼šè¿”å›ä¸€ä¸ªrunnerå‡½æ•°ï¼Œæ‰‹åŠ¨è°ƒç”¨runnerå‡½æ•°ä¹Ÿå¯ä»¥å®ç°è§¦å‘ä¾èµ–ï¼Œä¸å¿…ç­‰å¾…reactiveå¯¹è±¡çš„setæ“ä½œæ‰§è¡Œã€‚å¦‚æœeffectçš„å›è°ƒå‡½æ•°æœ‰è¿”å›å€¼ï¼Œé‚£ä¹ˆrunnerå‡½æ•°è¢«æ‰§è¡Œä¹‹åçš„è¿”å›å€¼ä¹Ÿåº”è¯¥æ˜¯è¯¥effectå›è°ƒå‡½æ•°çš„è¿”å›å€¼ã€‚

å…ˆçœ‹ä»¥ä¸‹æµ‹è¯•ç”¨ä¾‹
```typescript
it('should return runner when effect was called', () => {
  let foo = 1
  let runner = effect(() => {
    foo++
    return 'foo'
  })
  expect(foo).toBe(2)
  let returnValue = runner()       // æ‰‹åŠ¨è§¦å‘ä¾èµ–
  expect(foo).toBe(3)
  expect(returnValue).toBe('foo')  // è¿”å›å€¼æ˜¯foo
})
```
ä¸è¿‡è¿™é‡Œrunner()æ‰§è¡Œçš„æ—¶å€™å°±æ˜¯æ‰§è¡Œçš„effect.run()æ–¹æ³•ï¼Œrunæ–¹æ³•é‡Œé¢çš„thisä¼šä¸¢å¤±å¯¹effectçš„æŒ‡å‘ï¼Œæ‰€ä»¥è¿™é‡Œåº”è¯¥å¯¹runæ”¹å˜thisæŒ‡å‘ï¼Œè®©ä»–é‡æ–°ç»‘å®šä¸ºeffectå¯¹è±¡ã€‚
```typescript
// æ ¹æ®å®˜æ–¹ç»™å‡ºçš„ä»‹ç»ï¼šeffectä¼šç«‹å³è§¦å‘è¿™ä¸ªå‡½æ•°ï¼ŒåŒæ—¶å“åº”å¼è¿½è¸ªå…¶ä¾èµ–
export function effect<T = any>(fn: () => T): EffectRunner {
  let _effect = new ReactiveEffect(fn)
  _effect.run()
  // æ³¨æ„è¿™é‡Œçš„thisæŒ‡å‘ï¼Œreturn å‡ºå»çš„runæ–¹æ³•ï¼Œæ–¹æ³•ä½“é‡Œéœ€è¦ç”¨åˆ°thisï¼Œä¸”thiså¿…é¡»æŒ‡å‘ReactiveEffectçš„å®ä¾‹å¯¹è±¡
  // ä¸ç”¨bindé‡æ–°ç»‘å®šthisï¼Œthisä¼šæŒ‡å‘undefined
  let runner = _effect.run.bind(_effect) as EffectRunner
  return runner
}
```
è¿˜æ²¡å®Œï¼Œè¿˜æœ‰ä¸€ä»¶äº‹~~ï¼ˆæˆé¾™å†é™©è®°è€çˆ¹å£å»ï¼‰ï¼ŒReactiveEffectçš„run()æ–¹æ³•å¿…é¡»è¿”å›effectå›è°ƒå‡½æ•°çš„è¿”å›å€¼ï¼Œè¿™æ ·çš„è¯runner()æ‰§è¡Œçš„æ—¶å€™å°±èƒ½å¾—åˆ°effectå›è°ƒå‡½æ•°çš„è¿”å›å€¼äº†ã€‚
```typescript
class ReactiveEffect {
  constructor(public fn: Function, public scheduler?: EffectScheduler) {}
  run() {
    activeEffect = this
    let returnValue = this.fn() 
    return returnValue
  }
}
```


## scheduler
`scheduler`æ˜¯effectç¬¬äºŒä¸ªå½¢å‚`option`çš„å¯é€‰å±æ€§ï¼Œå®ƒæ˜¯ä¸€ä¸ªå‡½æ•°

è¯¥åŠŸèƒ½æè¿°ï¼š

1. `effect`é¦–æ¬¡æ‰§è¡Œçš„æ—¶å€™ä¸æ‰§è¡Œ`scheduler`,ç›´æ¥æ‰§è¡Œeffectçš„å›è°ƒå‡½æ•°
2. ä¹‹åæ¯æ¬¡è§¦å‘`trigger`å‡½æ•°çš„æ—¶å€™éƒ½ä¼šæ‰§è¡Œ`scheduler`å‡½æ•°ï¼Œä¸æ‰§è¡Œeffectå›è°ƒå‡½æ•°
3. å½“è°ƒç”¨`run()`çš„æ—¶å€™æ‰ä¼šè§¦å‘`runner`ï¼Œä¹Ÿå°±æ˜¯è¯´è°ƒç”¨effectçš„å›è°ƒå‡½æ•°

åœ¨è¿™é‡Œæˆ‘ç›´æ¥æ‹¿vueæºç çš„ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹äº†
```typescript
it('scheduler', () => {
  let dummy
  let run: any
  const scheduler = jest.fn(() => {
    run = runner
  })
  const obj = reactive({ foo: 1 })
  const runner = effect(
    () => {
      dummy = obj.foo
    },
    { scheduler }
  )
  expect(scheduler).not.toHaveBeenCalled()
  expect(dummy).toBe(1)
  // should be called on first trigger setæ“ä½œçš„æ—¶å€™,ä¹Ÿå°±æ˜¯è¯´åœ¨triggerè¢«è°ƒç”¨çš„æ—¶å€™
  obj.foo++
  expect(scheduler).toHaveBeenCalledTimes(1)
  // should not run yet
  expect(dummy).toBe(1)
  // manually run  ä¼šè§¦å‘effectçš„å›è°ƒå‡½æ•°
  run()
  // should have run
  expect(dummy).toBe(2)
})
```
å®ç°èµ·æ¥ä¹Ÿç›¸å¯¹ç®€å•ï¼Œ`effect`å‡½æ•°æ–°å¢ç¬¬äºŒä¸ªå‚æ•°optionå¯¹è±¡å¹¶ä¸”é‡Œé¢æœ‰ä¸€ä¸ªç±»å‹ä¸ºfunctionçš„`scheduler`å±æ€§ï¼Œä½œä¸ºå¯é€‰å€¼çš„å­˜åœ¨ã€‚ç»“åˆæ¡ä»¶1ï¼šé¦–æ¬¡æ‰§è¡Œeffectä¸ä¼šè°ƒç”¨schedulerå’Œæ¡ä»¶2ï¼šæ¯æ¬¡è§¦å‘`trigger`å‡½æ•°çš„æ—¶å€™éƒ½ä¼šæ‰§è¡Œ`scheduler`å‡½æ•°å¯ä»¥æ¨æ•²å‡º`scheduler()`çš„è°ƒç”¨åº”è¯¥åœ¨`trigger`é‡Œé¢ï¼Œå¹¶ä¸”ç”¨ifåˆ¤æ–­scheduleræ˜¯å¦æœ‰å€¼ï¼Œè¦ä¹ˆæ‰§è¡Œ`effect`çš„`run()`æ–¹æ³•è¦ä¹ˆæ‰§è¡Œeffectçš„`scheduler()`æ–¹æ³•ã€‚
```typescript
export function trigger(target: Record<EffectKey, any>, key: EffectKey) {

  const depsMap = targetMap.get(target)
  const deps = depsMap?.get(key)
  if (deps) {
    // depsæ˜¯Seté›†åˆ é‡Œé¢çš„å­å…ƒç´ æ˜¯ReactiveEffectå®ä¾‹å¯¹è±¡
    for (let dep of deps) {
      // ifåˆ¤æ–­scheduleræ˜¯å¦æœ‰å€¼
      if (dep.scheduler) {
        dep.scheduler()
      } else {
        dep.run()
      }
    }
  }
}
```
`effect()`çš„æ”¹å†™ä¹Ÿå¾ˆç®€å•ï¼Œåªéœ€è¦ä½œä¸ºå¯é€‰é…ç½®ä¼ å…¥ä¸€ä¸ª`option`å¯¹è±¡ï¼Œé€šè¿‡`extend`æŠŠ`option`é‡Œé¢çš„å±æ€§æŒ‚è½½åˆ°`ReactiveEffect`çš„å®ä¾‹å¯¹è±¡å³å¯ï¼ŒåŠ¡å¿…åœ¨ReactiveEffectä¸Šæ·»åŠ å…¬æœ‰æˆå‘˜`scheduler`ï¼Œè¿™é‡Œè¯´ä¸€ä¸‹`extend`ï¼Œå…¶å®å®ƒå°±æ˜¯[`Object.assign`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)ï¼Œä½œç”¨æ˜¯æŠŠå¯¹è±¡æŒ‚è½½åˆ°å¦ä¸€ä¸ªå¯¹è±¡ä¸Š
```typescript
export function effect<T = any>(fn: () => T, option?: EffectOption): EffectRunner {
  let _effect = new ReactiveEffect(fn)
  if(option){
    extend(_effect, option) // ç­‰ä»·äºObject.assign(_effect, option)
  }
  _effect.run()
  let runner = _effect.run.bind(_effect) as EffectRunner
  return runner
}
class ReactiveEffect {
  public deps: Set<ReactiveEffect>[] = []
  constructor(public fn: Function, public scheduler?: EffectScheduler) {}
  run() {
    activeEffect = this
    let returnValue = this.fn()
    return returnValue
  }
}
```
## stop & onStop
æˆ‘ä»¬æœ‰ç›‘å¬ä¾èµ–çš„åŠŸèƒ½å½“ç„¶ä¹Ÿå°‘ä¸äº†åœæ­¢ç›‘å¬ä¾èµ–çš„åŠŸèƒ½ã€‚

åœæ­¢ç›‘å¬ä¾èµ–æœ¬è´¨ä¸Šå°±æ˜¯æŠŠ`effect`ä»`deps`(Seté›†åˆ)é‡Œé¢deleteæ‰ï¼Œé‚£ä¹ˆå½“`trigger`è¢«å†æ¬¡è§¦å‘çš„æ—¶å€™å°±ä¸ä¼šæ‰§è¡Œè¯¥`effect`çš„`run()`æ–¹æ³•äº†ã€‚

å¦‚æœæˆ‘ä»¬æƒ³åœ¨åœæ­¢ç›‘å¬ä¾èµ–ä¹‹ååšç‚¹ä»€ä¹ˆäº‹æƒ…ï¼Œé‚£æˆ‘ä»¬å¯ä»¥ç”¨`onStop`å›è°ƒå‡½æ•°ï¼Œå®ƒå’Œ`scheduler`ä¸€æ ·ä¹Ÿæ˜¯åœ¨effectå‡½æ•°çš„ç¬¬äºŒä¸ªå¯é€‰å½¢å‚`option`å®šä¹‰ï¼Œè§¦å‘æ—¶æœºä¹Ÿå¾ˆç®€å•ï¼Œå°±æ˜¯å½“ä¾èµ–è¢«åˆ é™¤åæ‰§è¡Œ`onStop()`å°±å¥½äº†

ä»¥ä¸‹ä¸ºeffectçš„optionç±»å‹å®šä¹‰
```typescript
export type EffectScheduler = (...args: any[]) => any
export interface EffectOption {
  scheduler?: EffectScheduler
  onStop?: () => void
}
```
### å®ç°stopåœæ­¢ç›‘å¬ä¾èµ–
åŠŸèƒ½æè¿°ï¼š

ğŸ§ é€šè¿‡stopå¯ä»¥åœæ­¢ç›‘å¬ä¾èµ–ï¼Œæ€ä¹ˆæ ·åœæ­¢ç›‘å¬ä¾èµ–å‘¢ï¼Ÿ

å¯ä»¥é€šè¿‡åˆ é™¤depsä¾èµ–ï¼Œé‚£ä¹ˆtriggerè¢«è°ƒç”¨çš„æ—¶å€™å°±ä¸ä¼šè¢«å¾ªç¯è°ƒç”¨è¿™ä¸ªä¾èµ–äº†

æˆ‘ä»¬ç»§ç»­é€šè¿‡æµ‹è¯•é©±åŠ¨æˆ‘ä»¬çš„å®ç°
```typescript

it('stop', () => {
  let dummy
  const obj = reactive({ prop: 1 })
  const runner = effect(() => {
    dummy = obj.prop
  })
  obj.prop = 2
  expect(dummy).toBe(2)
  stop(runner)
  // æ‰§è¡Œproxyçš„setæ“ä½œï¼Œè§¦å‘trigger()
  obj.prop = 3
  expect(dummy).toBe(2)
  // stopped effect should still be manually callable
  runner()
  expect(dummy).toBe(3)
})
```
å®šä¹‰`stop()`å‡½æ•°ï¼Œå¹¶ä¼ å…¥ä¸€ä¸ª`runner`å‡½æ•°ï¼ˆeffect.run()çš„å‡½æ•°ä½“ï¼‰

ğŸ§ è¿™é‡Œæœ‰ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯æˆ‘ä»¬è¦æ€ä¹ˆæ‹¿åˆ°runnerå¯¹åº”çš„`effect`å‘¢ï¼Ÿ

runnerå¹¶æ²¡æœ‰ä»»ä½•çº¿ç´¢æŒ‡å‘å“ªä¸ª`effect`ï¼Œæˆ‘ä»¬æ‹¿åˆ°effectå†æ‹¿åˆ°effectæ‰€åœ¨çš„`deps`ï¼ˆ`Set<ReactiveEffect>`ï¼‰æ‰å¥½ delete æ‰å•Šã€‚è¿™é‡Œæœ‰ä¸ªåå‘çš„æ€ç»´ä¸”ç”¨åˆ°äº†jsä¸­å‡½æ•°çš„ç‰¹æ€§ï¼š

> å‡½æ•°ä¹Ÿæ˜¯å¯¹è±¡ï¼Œå‡½æ•°å¯¹è±¡ä¸Šå¯ä»¥ç›´æ¥å®šä¹‰å±æ€§

è®©æˆ‘ä»¬æ”¹å†™ä¸€ä¸‹`effect()`å‡½æ•°ï¼š
```typescript
// é‡Œé¢å­˜æœ‰ä¸€ä¸ªåŒ¿åå‡½æ•°
export interface EffectRunner<T = any> {
  (): T
  effect: ReactiveEffect
}
export function effect<T = any>(fn: () => T, option?: EffectOption): EffectRunner {
  let _effect = new ReactiveEffect(fn)
  if(option){
    extend(_effect, option)
  }
  _effect.run()
  let runner = _effect.run.bind(_effect) as EffectRunner
  // è¿™é‡Œçš„effectæŒ‚è½½åœ¨äº†å‡½æ•°runnerä¸Šï¼Œä½œä¸ºå±æ€§ï¼Œè¿™æ˜¯åˆ©ç”¨äº†jsä¸­å‡½æ•°å¯ä»¥æŒ‚åœ¨å±æ€§çš„ç‰¹æ€§
  // ä¹‹åå‘¢ï¼Œå®ç°stopçš„æ—¶å€™runnerå°±èƒ½æ‹¿åˆ°ReactiveEffectå®ä¾‹å¯¹è±¡äº†
  runner.effect = _effect
  return runner
}
```
ğŸ§ å¥½äº†ç°åœ¨æˆ‘ä»¬å·²ç»æ‹¿åˆ°äº† runner çš„ effect äº†ï¼Œä¸Šé¢æˆ‘ä»¬æåˆ°ä¸€ä¸ªåå‘çš„æ€ç»´æ€ä¹ˆè§£é‡Šå‘¢ï¼Ÿ

å³depsé›†åˆï¼ˆ`Set<ReactiveEffect>`ï¼‰å­˜å‚¨ç€ç›¸å…³keyçš„effectï¼Œä¸å¦¨åè¿‡æ¥ï¼Œ`ReactiveEffect`ç±»é‡Œé¢å®šä¹‰ä¸€ä¸ªå…¬æœ‰æˆå‘˜å˜é‡æ•°ç»„ï¼Œç”¨äºå­˜å‚¨depsé›†åˆï¼Œæ¯ä¸ªeffectå¯¹è±¡éƒ½æœ‰è¯¥æ•°ç»„å­˜æ”¾depsé›†åˆçš„ä¹‹åï¼Œå°±å¯ä»¥ç”¨å¾ªç¯çš„æ–¹å¼æ‰¾å‡ºeffectå¹¶ä»depsé›†åˆä¸­åˆ é™¤å°±å¯ä»¥äº†ã€‚

å› ä¸ºåœæ­¢ç›‘å¬ä¾èµ–æ˜¯å±äºä¾èµ–è¡Œä¸ºèŒƒç•´çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦åœ¨`ReactiveEffect`ç±»å®šä¹‰ä¸€ä¸ª`stop()`æ–¹æ³•ï¼Œè¿™æ ·æ‰ç¬¦åˆé¢å‘å¯¹è±¡çš„æ€æƒ³å˜›ã€‚

```typescript
class ReactiveEffect {
  // æ­¤å¤„depså°±æ˜¯æ•°ç»„ï¼Œæ•°ç»„æ¯ä¸ªå…ƒç´ å­˜å‚¨çš„Seté›†åˆ
  public deps: Set<ReactiveEffect>[] = []
  constructor(public fn: Function, public scheduler?: EffectScheduler) {}
  ...
  stop() {
    // depsæ˜¯Seté›†åˆ
    for (let i = 0; i < this.deps.length; i++) {
      this.deps[i].delete(this)
    }
    this.deps.length = 0
  }
}
```
ğŸ§ å¥½äº†æ–°çš„é—®é¢˜å‡ºæ¥äº†ï¼Œé‚£ä¹ˆä»€ä¹ˆæ—¶å€™effectåº”è¯¥pushè¿›effect.depså‘¢ï¼Ÿ

ä¾èµ–è¢«æ”¶é›†çš„æ—¶å€™å°±åº”è¯¥æ˜¯æœ€å¥½çš„æ—¶æœºäº†ï¼Œä¹Ÿå°±æ˜¯è¯´trackè¢«è§¦å‘çš„æ—¶å€™åº”è¯¥`activeEffect.deps.push(deps)`
```typescript
export function track(target: Record<EffectKey, any>, key: EffectKey) {
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    depsMap = new Map()
    targetMap.set(target, depsMap)
  }
  let deps = depsMap.get(key)
  if (!deps) {
    deps = new Set()
    depsMap.set(key, deps)
  }
  deps.add(activeEffect)
  // activeEffectçš„deps æ¥æ”¶ Set<ReactiveEffect>ç±»å‹çš„deps
  // ä¾›åˆ é™¤ä¾èµ–çš„æ—¶å€™ä½¿ç”¨(åœæ­¢ç›‘å¬ä¾èµ–)
  activeEffect.deps.push(deps)
}
```
å› ä¸ºè¿™é‡Œrunnerå·²ç»æŒ‚è½½äº†ä¸€ä¸ª`effect`å¯¹è±¡ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥è°ƒç”¨`effect.stop()`æ–¹æ³•ç”¨äºåœæ­¢ç›‘å¬ä¾èµ–ã€‚
```typescript
export function stop(runner: EffectRunner) {
  runner.effect.stop()
}
```

### å®ç°onStopåœæ­¢ç›‘å¬ä¾èµ–åæ‰§è¡Œçš„å›è°ƒå‡½æ•°

æˆ‘ä»¬å›é¡¾ä¸€ä¸‹ï¼šè¯¥onStopéœ€è¦ä»effect()çš„optionå‚æ•°ä½œä¸ºå¯é€‰å±æ€§ä¼ é€’è¿›æ¥ï¼Œå› ä¸ºæˆ‘ä»¬å®ç°äº†ä¸€ä¸ªå·¥å…·å‡½æ•°extend()ï¼Œå®ƒå¯ä»¥å°†optionæŒ‚è½½åœ¨ReactiveEffectç±»çš„å®ä¾‹å¯¹è±¡effectä¸Šã€‚

æ‰€ä»¥åªéœ€è¦åœ¨å¾ªç¯depsæ•°ç»„å¹¶åœ¨æ¯ä¸ªSeté›†åˆä¸­æ‰¾å‡ºè¦åˆ é™¤çš„effectç„¶å`delete`è¿™ä¸ªæ“ä½œä¹‹åï¼Œæ‰§è¡ŒonStopå³å¯ï¼ŒåŒæ ·è¦åœ¨ReactiveEffectç±»ä¸­å®šä¹‰ä¸€ä¸ªä¸ªå…¬æœ‰æˆå‘˜å˜é‡onStopå¹¶ç½®ä¹‹ä¸ºå¯é€‰å±æ€§ã€‚
```typescript
class ReactiveEffect {
  public deps: Set<ReactiveEffect>[] = []
  public onStop?: () => void  // å¯é€‰å±æ€§
  constructor(public fn: Function, public scheduler?: EffectScheduler) {}
  ...
  stop() {
    for (let i = 0; i < this.deps.length; i++) {
      this.deps[i].delete(this)
    }
    this.deps.length = 0
    // å½“onStopæœ‰å€¼çš„æ—¶å€™ï¼Œæ‰§è¡ŒonStop()
    this.onStop?.()
  }
}
```

## ä»£ç ä¼˜åŒ–

ä¼˜åŒ–ç‚¹ï¼š
1. å¦‚æœç”¨æˆ·è°ƒç”¨å¤šæ¬¡`stop()`å¹¶ä¸”ä¼ å…¥çš„éƒ½æ˜¯ç›¸åŒçš„runneræ¥åœæ­¢ç›‘å¬ä¾èµ–ï¼Œé‚£ä¹ˆä»£ç å°†ä¼šæ‰§è¡Œä¸å¿…è¦çš„å¾ªç¯æ“ä½œï¼ˆstopé‡Œé¢æœ‰å¾ªç¯æ¥æ‰¾å‡ºå“ªä¸ªåº”è¯¥è¢«deleteæ‰ï¼‰ï¼Œé™ä½ä»£ç æ€§èƒ½ã€‚åº”è¯¥æ·»åŠ ä¸€ä¸ª`active`ä½œä¸ºæˆå‘˜å˜é‡åˆ°ReactiveEffectç±»ï¼Œç”¨äºæ ‡è¯†ä¾èµ–æ˜¯å¦å·²ç»è¢«deleteæ‰äº†ï¼Œæ€æ­»æ‰äº†ã€‚

* åŒæ—¶stopå¾ªç¯çš„ä»£ç æ®µä¹Ÿåº”è¯¥è¢«æå–å‡ºæ¥ä½œä¸ºå•ç‹¬çš„å‡½æ•°ï¼Œæˆ‘ä»¬å‘½åä¸º`cleanupEffect`å¥½äº†ã€‚
```typescript
class ReactiveEffect {
  public deps: Set<ReactiveEffect>[] = []
  public active = true  // è¯¥effectæ˜¯å¦å­˜æ´»
  public onStop?: () => void
  constructor(public fn: Function, public scheduler?: EffectScheduler) {}
  ...
  stop() {
    // è¿½åŠ active æ ‡è¯†æ˜¯ä¸ºäº†æ€§èƒ½ä¼˜åŒ–ï¼Œé¿å…æ¯æ¬¡å¾ªç¯é‡å¤è°ƒç”¨stopåŒä¸€ä¸ªä¾èµ–çš„æ—¶å€™
    if (this.active) {
      cleanupEffect(this)
      this.onStop?.()
      this.active = false
    }
  }
}
// æ¸…é™¤æŒ‡å®šä¾èµ–
function cleanupEffect(effect: ReactiveEffect) {
  // å¯¹effectè§£æ„ï¼Œè§£å‡ºdepsï¼Œå‡å°‘å¯¹è±¡åœ¨è¯æ³•ç¯å¢ƒå¯»æ‰¾å±æ€§çš„æ¬¡æ•°
  const {deps} = effect
  if (deps.length !== 0) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect)
    }
    deps.length = 0
  }
}
```
   
2. vueå¯¹stopåŠŸèƒ½çš„å®˜æ–¹æµ‹è¯•ç”¨ä¾‹å¹¶ä¸ä¸¥è°¨ï¼Œåªæ£€æŸ¥äº†setæ“ä½œï¼Œå¹¶æ²¡æœ‰é‡åˆ°getæ“ä½œçš„æƒ…å†µ
```typescript
 it('stop', () => {
    let dummy
    const obj = reactive({ prop: 1 })
    const runner = effect(() => {
      dummy = obj.prop
    })
    obj.prop = 2
    expect(dummy).toBe(2)
    stop(runner)
    // å•å•åªæ˜¯æ£€æŸ¥setæ“ä½œæ˜¯ä¸è¡Œçš„ï¼Œè¿˜å¿…é¡»æ£€æŸ¥ä»£ç é€šè¿‡getæ“ä½œä¹‹åï¼Œæ˜¯å¦è¿˜èƒ½æ‰§è¡Œä¾èµ–
    // obj.prop = 3
    // å¾ˆæ˜æ˜¾å¦‚æœæ¢æˆobj.prop++ï¼Œexpect(dummy).toBe(2)å°±é£˜çº¢äº†
    
    obj.prop++
    expect(dummy).toBe(2)     âŒ
    runner()
    expect(dummy).toBe(3)
  })
```
ğŸ§ æˆ‘ä»¬æ€è€ƒä¸€ä¸‹ä¸ºä»€ä¹ˆæŠŠ`obj.prop = 3`æ¢æˆ`obj.prop++`æµ‹è¯•ç”¨ä¾‹å°±ä¸é€šè¿‡å‘¢ï¼Ÿ

`obj.prop++` ---æ‹†è§£--> `obj.prop = obj.prop + 1` å¾ˆæ˜æ˜¾è¿™é‡Œå¤šäº†ä¸€ä¸ªgetæ“ä½œã€‚å…ˆgetåsetã€‚

ğŸ¤¯è§£é‡Šï¼šç»è¿‡getæ“ä½œä¹‹åï¼Œä¹Ÿå°±æ˜¯è¯´æ‰§è¡Œtrackå‡½æ•°ä¹‹ååŸæ¥è¢«åˆ é™¤çš„effectåˆè¢«addåˆ°depsä¸Šé¢å»äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿™é‡Œå¿…é¡»æ·»åŠ `shouldTrack`å…¨å±€å˜é‡æ¥è¡¨ç¤ºåº”ä¸åº”è¯¥è¢«`track` è¯¦ç»†è§effect.tsçš„ track å‡½æ•°ï¼Œæ§åˆ¶`shouldTrack`å¼€å…³åœ¨ReactiveEffectçš„`run()`æ–¹æ³•ä¸­ã€‚`shouldTrack`çš„åˆå§‹å€¼ä¸º false ï¼Œä»£è¡¨ä¸å¯è¢«trackã€‚å½“ä¾èµ–æ­£å¼å¯å›æ”¶çš„æ—¶å€™ï¼ˆæ²¡æœ‰è¢«åˆ é™¤ï¼‰ï¼Œç½®`shouldTrack`ä¸º true ï¼Œè¡¨ç¤ºå¯è¢«trackã€‚

è®©æˆ‘ä»¬æ”¹å†™ä¸€ä¸‹`ReactiveEffect`ç±»
```typescript
class ReactiveEffect {
  public deps: Set<ReactiveEffect>[] = []
  public active = true  // è¯¥effectæ˜¯å¦å­˜æ´»
  public onStop?: () => void
  constructor(public fn: Function, public scheduler?: EffectScheduler) {}
  run() {
    // å¦‚æœeffectå·²ç»è¢«æ€æ­»äº†ï¼Œè¢«åˆ é™¤äº†ï¼ˆstop()å‡½æ•°ç›¸å…³ï¼‰
    if (!this.active) {
      return this.fn()
    }
    activeEffect = this
    shouldTrack = true // æŠŠå¼€å…³æ‰“å¼€è®©ä»–å¯ä»¥æ”¶é›†ä¾èµ–
    let returnValue = this.fn()
    // ä¹‹åæŠŠshouldTrackå…³é—­ï¼Œè¿™æ ·å°±æ²¡åŠæ³•åœ¨trackå‡½æ•°é‡Œé¢æ”¶é›†ä¾èµ–äº†
    shouldTrack = false

    return returnValue
  }
  ...
}
```
å½“æ‰§è¡Œ`this.fn()`çš„æ—¶å€™ï¼Œfné‡Œé¢ä¼šæ‰§è¡Œgetæ“ä½œï¼Œä¹‹åå°±ä¼šæ‰§è¡Œtrackæ”¶é›†ä¾èµ–ï¼Œå› ä¸ºshouldTrackæ˜¯trueï¼Œæ‰€ä»¥ä¾èµ–æ”¶é›†èƒ½é¡ºåˆ©å®Œæˆã€‚å¼€å¤´åˆ¤æ–­`this.active`æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœä¸ºç©ºï¼Œé‚£ä¹ˆeffectå°†ä¼šè¢«æ‰§è¡Œè€Œä¸ä¼šæ”¶é›†ä¾èµ–ï¼Œè¿›å…¥trackå°±é©¬ä¸Šè¢«returnæ‰äº†ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºäº†å¦‚æœç”¨æˆ·å•å•è°ƒç”¨`runner()`çš„æ—¶å€™èƒ½å¤Ÿæ‰§è¡Œeffectå›è°ƒå‡½æ•°ï¼ˆå±äºæ‰‹åŠ¨è§¦å‘ä¾èµ–ï¼‰ç•™çš„åè·¯ã€‚
```typescript
export function track(target: Record<EffectKey, any>, key: EffectKey) {
  // è¿™é‡Œä¸ºä»€ä¹ˆè¦å¤šä¸€å±‚éç©ºåˆ¤æ–­å‘¢ï¼Ÿ
  // æˆ‘ä»¬æŸ¥çœ‹reactive.spec.tsé‡Œé¢çš„æµ‹è¯•ç”¨ä¾‹
  // æµ‹è¯•ç”¨ä¾‹é‡Œæ ¹æœ¬å°±æ²¡æœ‰è°ƒç”¨effect()ï¼Œæ‰€ä»¥æ²¡æœ‰æ‰§è¡ŒReactiveEffectçš„run()è‡ªç„¶activeEffectä¹Ÿå°±æ˜¯undefinedäº†
  if (!activeEffect) return
  // åº”ä¸åº”è¯¥æ”¶é›†ä¾èµ–ï¼Œä»è€Œé¿å…åˆ äº†ä¾èµ–åˆé‡æ–°æ·»åŠ æ–°çš„ä¾èµ–
  if (!shouldTrack) return

  let depsMap = targetMap.get(target)
  
  if (!depsMap) {
    depsMap = new Map()
    targetMap.set(target, depsMap)
  }
  let deps = depsMap.get(key)
  if (!deps) {
    deps = new Set()
    depsMap.set(key, deps)
  }
  deps.add(activeEffect)
  activeEffect.deps.push(deps)
}
```
3. é¿å…`deps.add(activeEffect)`æ— æ•ˆæ‰§è¡Œå’Œtrackä¸­è·³å‡ºå‡½æ•°ä½“çš„ä»£ç æ®µæŠ½ç¦»
   
   * ç”¨Setå®ä¾‹çš„æ–¹æ³•`has`æ¥åˆ¤æ–­æ˜¯å¦å·²ç»æ”¶é›†è¿‡ä¾èµ–ï¼Œå¦‚æœæ²¡æœ‰æ”¶é›†è¿‡ä¾èµ–ï¼Œé‚£ä¹ˆå°±æ”¶é›†ä¾èµ–ï¼Œå¦‚æœå·²ç»æ”¶é›†è¿‡ä¾èµ–ï¼Œé‚£ä¹ˆå°±ä¸å†æ”¶é›†ä¾èµ–ã€‚
   * å®šä¹‰ä¸€ä¸ªå‡½æ•°`isTracking`è¡¨ç¤ºå½“å‰æ˜¯å¦åœ¨trackçš„çŠ¶æ€
```typescript
function isTracking(){
  return activeEffect !== undefined && shouldTrack
}
export function track(target: Record<EffectKey, any>, key: EffectKey) {
  // æ‹¦æˆªä¸å¿…è¦çš„track
  if (!isTracking()) return
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    depsMap = new Map()
    targetMap.set(target, depsMap)
  }
  let deps = depsMap.get(key)
  if (!deps) {
    deps = new Set()
    depsMap.set(key, deps)
  }
  // é¿å…ä¸å¿…è¦çš„addæ“ä½œ
  if (deps.has(activeEffect)) return

  deps.add(activeEffect)
  activeEffect.deps.push(deps)
}
```
## æ€»ç»“


## æœ€å@æ„Ÿè°¢é˜…è¯»ï¼

## å®Œæ•´ä»£ç 
```typescript
// in effect.ts

import {extend} from '../shared/index'
export type EffectScheduler = (...args: any[]) => any
class ReactiveEffect {
  public deps: Set<ReactiveEffect>[] = []
  public active = true  // è¯¥effectæ˜¯å¦å­˜æ´»
  public onStop?: () => void
  constructor(public fn: Function, public scheduler?: EffectScheduler) {}
  run() {
    // å¦‚æœeffectå·²ç»è¢«æ€æ­»äº†ï¼Œè¢«åˆ é™¤äº†ï¼ˆstop()å‡½æ•°ç›¸å…³ï¼‰
    if (!this.active) {
      return this.fn()
    }
    // ä¸ºä»€ä¹ˆè¦åœ¨è¿™é‡ŒæŠŠthisèµ‹å€¼ç»™activeEffectå‘¢ï¼Ÿå› ä¸ºè¿™é‡Œæ˜¯fnæ‰§è¡Œä¹‹å‰ï¼Œå°±æ˜¯trackä¾èµ–æ”¶é›†æ‰§è¡Œä¹‹å‰ï¼Œåˆæ˜¯effectå¼€å§‹æ‰§è¡Œä¹‹åï¼Œ
    // thisèƒ½æ•æ‰åˆ°è¿™ä¸ªä¾èµ–ï¼Œå°†è¿™ä¸ªä¾èµ–èµ‹å€¼ç»™activeEffectæ˜¯åˆšåˆšå¥½çš„æ—¶æœº
    activeEffect = this
    shouldTrack = true // æŠŠå¼€å…³æ‰“å¼€è®©ä»–å¯ä»¥æ”¶é›†ä¾èµ–
    let returnValue = this.fn() // æ‰§è¡Œfnçš„æ—¶å€™ï¼Œfné‡Œé¢ä¼šæ‰§è¡Œgetæ“ä½œï¼Œä¹‹åå°±ä¼šæ‰§è¡Œtrackæ”¶é›†ä¾èµ–ï¼Œå› ä¸ºshouldTrackæ˜¯trueï¼Œæ‰€ä»¥ä¾èµ–æ”¶é›†å®Œæˆ
    // ä¹‹åæŠŠshouldTrackå…³é—­ï¼Œè¿™æ ·å°±æ²¡åŠæ³•åœ¨trackå‡½æ•°é‡Œé¢æ”¶é›†ä¾èµ–äº†
    shouldTrack = false

    return returnValue
  }
  stop() {
    // è¿½åŠ active æ ‡è¯†æ˜¯ä¸ºäº†æ€§èƒ½ä¼˜åŒ–ï¼Œé¿å…æ¯æ¬¡å¾ªç¯é‡å¤è°ƒç”¨stopåŒä¸€ä¸ªä¾èµ–çš„æ—¶å€™
    if (this.active) {
      cleanupEffect(this)
      this.onStop?.()
      this.active = false
    }
  }
}
// æ¸…é™¤æŒ‡å®šä¾èµ–
function cleanupEffect(effect: ReactiveEffect) {
  // å¯¹effectè§£æ„ï¼Œè§£å‡ºdepsï¼Œå‡å°‘å¯¹è±¡åœ¨è¯æ³•ç¯å¢ƒå¯»æ‰¾å±æ€§çš„æ¬¡æ•°
  const {deps} = effect
  if (deps.length !== 0) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect)
    }
    deps.length = 0
  }
}
const targetMap = new Map<Record<EffectKey, any>, Map<EffectKey, Set<IDep>>>()
// å½“å‰æ­£åœ¨æ‰§è¡Œçš„effect
let activeEffect: ReactiveEffect
let shouldTrack = false
type EffectKey = string
type IDep = ReactiveEffect
// è¿™ä¸ªtrackçš„å®ç°é€»è¾‘å¾ˆç®€å•ï¼šæ·»åŠ ä¾èµ–
export function track(target: Record<EffectKey, any>, key: EffectKey) {
  // è¿™é‡Œä¸ºä»€ä¹ˆè¦å¤šä¸€å±‚éç©ºåˆ¤æ–­å‘¢ï¼Ÿ
  // æˆ‘ä»¬æŸ¥çœ‹reactive.spec.tsé‡Œé¢çš„æµ‹è¯•ç”¨ä¾‹
  // æµ‹è¯•ç”¨ä¾‹é‡Œæ ¹æœ¬å°±æ²¡æœ‰è°ƒç”¨effect()ï¼Œæ‰€ä»¥æ²¡æœ‰æ‰§è¡ŒReactiveEffectçš„run()è‡ªç„¶activeEffectä¹Ÿå°±æ˜¯undefinedäº†
  // if (!activeEffect) return
  // åº”ä¸åº”è¯¥æ”¶é›†ä¾èµ–ï¼Œä»è€Œé¿å…åˆ äº†ä¾èµ–åˆé‡æ–°æ·»åŠ æ–°çš„ä¾èµ–
  // if (!shouldTrack) return
  if (!isTracking()) return
  // å¯»æ‰¾depä¾èµ–çš„æ‰§è¡Œé¡ºåº
  // target -> key -> dep
  let depsMap = targetMap.get(target)
  /**
   * è¿™é‡Œæœ‰ä¸ªç–‘é—®ï¼štargetä¸º{ num: 11 } çš„æ—¶å€™æˆ‘ä»¬èƒ½è·å–åˆ°depsMapï¼Œä¹‹åæˆ‘ä»¬count.num++ï¼Œä¸ºä»€ä¹ˆtargetä¸º{ num: 12 } çš„æ—¶å€™æˆ‘ä»¬è¿˜èƒ½è·å–å¾—åˆ°ç›¸åŒçš„depsMapå‘¢ï¼Ÿ
   * è¿™é‡Œæˆ‘çš„ç†è§£æ˜¯ targetMapçš„keyå­˜çš„åªæ˜¯targetçš„å¼•ç”¨ å­˜çš„å­—ç¬¦ä¸²å°±ä¸ä¸€æ ·äº†
   */
  // è§£å†³åˆå§‹åŒ–æ²¡æœ‰depsMapçš„æƒ…å†µ
  if (!depsMap) {
    depsMap = new Map()
    targetMap.set(target, depsMap)
  }
  // depsæ˜¯ä¸€ä¸ªSetå¯¹è±¡ï¼Œå­˜æ”¾ç€è¿™ä¸ªkeyç›¸å¯¹åº”çš„æ‰€æœ‰ä¾èµ–
  let deps = depsMap.get(key)
  // å¦‚æœæ²¡æœ‰keyç›¸å¯¹åº”çš„Set åˆå§‹åŒ–Set
  if (!deps) {
    deps = new Set()
    depsMap.set(key, deps)
  }
  // é¿å…ä¸å¿…è¦çš„addæ“ä½œ
  if (deps.has(activeEffect)) return
  // å°†activeEffectå®ä¾‹å¯¹è±¡addç»™deps
  deps.add(activeEffect)
  // activeEffectçš„deps æ¥æ”¶ Set<ReactiveEffect>ç±»å‹çš„deps
  // ä¾›åˆ é™¤ä¾èµ–çš„æ—¶å€™ä½¿ç”¨(åœæ­¢ç›‘å¬ä¾èµ–)
  activeEffect.deps.push(deps)
}
function isTracking(){
  
  return activeEffect !== undefined && shouldTrack
}
// è¿™ä¸ªtriggerçš„å®ç°é€»è¾‘å¾ˆç®€å•ï¼šæ‰¾å‡ºtargetçš„keyå¯¹åº”çš„æ‰€æœ‰ä¾èµ–ï¼Œå¹¶ä¾æ¬¡æ‰§è¡Œ
export function trigger(target: Record<EffectKey, any>, key: EffectKey) {

  const depsMap = targetMap.get(target)
  const deps = depsMap?.get(key)
  if (deps) {
    for (let dep of deps) {
      if (dep.scheduler) {
        dep.scheduler()
      } else {
        dep.run()
      }
    }
  }
}
export interface EffectOption {
  scheduler?: EffectScheduler
  onStop?: () => void
}
// é‡Œé¢å­˜æœ‰ä¸€ä¸ªåŒ¿åå‡½æ•°
export interface EffectRunner<T = any> {
  (): T
  effect: ReactiveEffect
}
// æ ¹æ®å®˜æ–¹ç»™å‡ºçš„ä»‹ç»ï¼šeffectä¼šç«‹å³è§¦å‘è¿™ä¸ªå‡½æ•°ï¼ŒåŒæ—¶å“åº”å¼è¿½è¸ªå…¶ä¾èµ–
export function effect<T = any>(fn: () => T, option?: EffectOption): EffectRunner {
  let _effect = new ReactiveEffect(fn)
  if(option){
    extend(_effect, option)
  }
  _effect.run()
  // æ³¨æ„è¿™é‡Œçš„thisæŒ‡å‘ï¼Œreturn å‡ºå»çš„runæ–¹æ³•ï¼Œæ–¹æ³•ä½“é‡Œéœ€è¦ç”¨åˆ°thisï¼Œä¸”thiså¿…é¡»æŒ‡å‘ReactiveEffectçš„å®ä¾‹å¯¹è±¡
  // ä¸ç”¨bindé‡æ–°ç»‘å®šthisï¼Œthisä¼šæŒ‡å‘undefined
  let runner = _effect.run.bind(_effect) as EffectRunner
  // è¿™é‡Œçš„effectæŒ‚è½½åœ¨äº†å‡½æ•°runnerä¸Šï¼Œä½œä¸ºå±æ€§ï¼Œè¿™æ˜¯åˆ©ç”¨äº†jsä¸­å‡½æ•°å¯ä»¥æŒ‚åœ¨å±æ€§çš„ç‰¹æ€§
  // ä¹‹åå‘¢ï¼Œstopçš„runnerå°±èƒ½æ‹¿åˆ°ReactiveEffectå®ä¾‹å¯¹è±¡äº†
  runner.effect = _effect
  return runner
}
export function stop(runner: EffectRunner) {
  runner.effect.stop()
}

```
```typescript
// in shared/index.ts
export const extend = Object.assign

```
```typescript
// all in effect.spec.ts
  // å®ç°effectè¿”å›runnerå‡½æ•° è¿™ä¸ªrunnerå‡½æ•°å…¶å®å°±æ˜¯effectçš„å›è°ƒå‡½æ•°
  it('should return runner when effect was called', () => {
    let foo = 1
    let runner = effect(() => {
      foo++
      return 'foo'
    })
    expect(foo).toBe(2)
    let returnValue = runner()
    expect(foo).toBe(3)
    expect(returnValue).toBe('foo')
  })
  // å®ç°effectçš„scheduleråŠŸèƒ½
  // è¯¥åŠŸèƒ½æè¿°ï¼š
  // 1. effecté¦–æ¬¡æ‰§è¡Œçš„æ—¶å€™ä¸æ‰§è¡Œscheduler,ç›´æ¥æ‰§è¡Œå›è°ƒå‡½æ•°
  // 2. ä¹‹åæ¯æ¬¡è§¦å‘triggerå‡½æ•°çš„æ—¶å€™éƒ½ä¼šæ‰§è¡Œschedulerå‡½æ•°ï¼Œä¸æ‰§è¡Œeffectå›è°ƒå‡½æ•°
  // 3. å½“è°ƒç”¨runçš„æ—¶å€™æ‰ä¼šè§¦å‘runnerï¼Œä¹Ÿå°±æ˜¯è¯´è°ƒç”¨effectçš„å›è°ƒå‡½æ•°
  it('scheduler', () => {
    let dummy
    let run: any
    const scheduler = jest.fn(() => {
      run = runner
    })
    const obj = reactive({ foo: 1 })
    const runner = effect(
      () => {
        dummy = obj.foo
      },
      { scheduler }
    )
    expect(scheduler).not.toHaveBeenCalled()
    expect(dummy).toBe(1)
    // should be called on first trigger setæ“ä½œçš„æ—¶å€™,ä¹Ÿå°±æ˜¯è¯´åœ¨triggerè¢«è°ƒç”¨çš„æ—¶å€™
    obj.foo++
    expect(scheduler).toHaveBeenCalledTimes(1)
    // should not run yet
    expect(dummy).toBe(1)
    // manually run  ä¼šè§¦å‘effectçš„å›è°ƒå‡½æ•°
    run()
    // should have run
    expect(dummy).toBe(2)
  })
  // å®ç°effectçš„stopåŠŸèƒ½
  // åŠŸèƒ½æè¿°ï¼š
  // é€šè¿‡stopå¯ä»¥åœæ­¢ç›‘å¬ä¾èµ–ï¼Œæ€ä¹ˆæ ·åœæ­¢ç›‘å¬ä¾èµ–å‘¢ï¼Ÿå¯ä»¥é€šè¿‡åˆ é™¤depsä¾èµ–ï¼Œé‚£ä¹ˆtriggerè¢«è°ƒç”¨çš„æ—¶å€™å°±ä¸ä¼šè¢«å¾ªç¯è°ƒç”¨è¿™ä¸ªä¾èµ–äº†
  it('stop', () => {
    let dummy
    const obj = reactive({ prop: 1 })
    const runner = effect(() => {
      dummy = obj.prop
    })
    obj.prop = 2
    expect(dummy).toBe(2)
    stop(runner)
    // å•å•åªæ˜¯æ£€æŸ¥setæ“ä½œæ˜¯ä¸è¡Œçš„ï¼Œè¿˜å¿…é¡»æ£€æŸ¥ä»£ç é€šè¿‡getæ“ä½œä¹‹åï¼Œæ˜¯å¦è¿˜èƒ½æ‰§è¡Œä¾èµ–
    // obj.prop = 3
    // å¾ˆæ˜æ˜¾å¦‚æœæ¢æˆobj.prop++ï¼Œexpect(dummy).toBe(2)å°±é£˜çº¢äº†
    // è¿™æ˜¯å› ä¸ºobj.propè¿˜æœ‰ä¸€ä¸ªgetæ“ä½œï¼Œç»è¿‡getæ“ä½œä¹‹åï¼Œç»è¿‡trackå‡½æ•°ä¹‹ååŸæ¥è¢«åˆ é™¤çš„effectåˆè¢«addåˆ°depsä¸Šé¢å»äº†
    // æ‰€ä»¥æˆ‘ä»¬è¿™é‡Œå¿…é¡»æ·»åŠ shouldtrackå˜é‡æ¥è¡¨ç¤ºåº”ä¸åº”è¯¥è¢«track è¯¦ç»†è§effect.tsçš„trackå‡½æ•°ï¼Œæ§åˆ¶shouldTrackå¼€å…³åœ¨ReactiveEffectçš„runæ–¹æ³•
    obj.prop++
    expect(dummy).toBe(2)

    // stopped effect should still be manually callable
    runner()
    expect(dummy).toBe(3)
  })
  // å®ç°onStop
  // åŠŸèƒ½æè¿°ï¼š
  // 1. å½“stopå¯¹ä¸€ä¸ªrunneræ‰§è¡Œçš„æ—¶å€™ï¼Œrunnerå¯¹åº”çš„ä¾èµ–çš„onStopå°±ä¼šè¢«æ‰§è¡Œï¼Œç›¸å½“äºäº‹ä»¶è§¦å‘
  it('onStop', () => {
    const obj = reactive({ foo: 1 })
    const onStop = jest.fn()
    let dummy
    const runner = effect(
      () => {
        dummy = obj.foo
      },
      {
        onStop,
      }
    )
    stop(runner)
    // è¢«è°ƒç”¨1æ¬¡
    expect(onStop).toBeCalledTimes(1)
  })
```
