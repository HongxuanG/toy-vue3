# ğŸš€ isReactive & isReadonly ä¸”åˆ©ç”¨Jestæµ‹è¯•å®ç°æ•°æ®å“åº”å¼ï¼ˆä¸€ï¼‰

> å±±ä¸åœ¨é«˜ï¼Œæœ‰ä»™åˆ™åã€‚æ°´ä¸åœ¨æ·±ï¼Œæœ‰é¾™åˆ™çµã€‚ â€”â€” åˆ˜ç¦¹é”¡ã€Šé™‹å®¤é“­ã€‹


## å‰è¨€
ä¸Šç¯‡å¯¹reactive & effectçš„è¡¥å……æš‚å‘Šä¸€æ®µè½ï¼Œè¿˜æ²¡çœ‹è¿‡ä¸Šä¸€ç¯‡çš„çœ‹è¿™é‡ŒğŸ‰
> [ğŸš€ reactive & effect ä¸”åˆ©ç”¨Jestæµ‹è¯•å®ç°æ•°æ®å“åº”å¼ï¼ˆä¸€ï¼‰](https://juejin.cn/post/7089244580394041375)
> 
> [ğŸš€ reactive & effect ä¸”åˆ©ç”¨Jestæµ‹è¯•å®ç°æ•°æ®å“åº”å¼ï¼ˆäºŒï¼‰](https://juejin.cn/post/7090165509735317534)

æ•´ç¯‡æ–‡ç« çš„é€šè¿‡`TDD`æµ‹è¯•é©±åŠ¨å¼€å‘ï¼Œå¸¦ä½ ä¸€æ­¥ä¸€æ­¥å®ç°vue3æºç ï¼Œæ–‡ç« çš„æœ€åè¿˜æœ‰å®Œæ•´ä»£ç å“¦ã€‚

æœ¬ç¯‡æ–‡ç« å†…å®¹åŒ…æ‹¬ï¼š
1. è®²è§£Readonlyçš„å®ç°å’Œå¯¹å·²æœ‰ä»£ç çš„é‡æ„
2. è®²è§£isReactiveçš„å®ç°æ€è·¯
3. è®²è§£isReadonlyçš„å®ç°æ€è·¯
4. åŸå§‹æ•°æ®åµŒå¥—ç»“æ„çš„å“åº”å¼
5. åæ€ç›®å‰ä»£ç çš„ä¸è¶³

## å®ç° Readonly

ä¸Šç¯‡æ–‡ç« æˆ‘ä»¬å·²ç»å®ç°äº†`reactive`ï¼Œå…¶å®`readonly`æ˜¯`reactive`çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µï¼Œåªä¸è¿‡æ˜¯åªè¯»çš„ã€‚å®ƒä¹Ÿæ˜¯è¿”å›ä¸€ä¸ª`proxy`å¯¹è±¡ï¼Œå¹¶æ²¡æœ‰setæ“ä½œï¼Œæ‰€ä»¥readonlyå¹¶æ²¡æœ‰ä¾èµ–è§¦å‘ï¼Œæ—¢ç„¶æ²¡æœ‰ä¾èµ–è§¦å‘ï¼Œé‚£ä¹ˆå®ƒä¹Ÿä¸éœ€è¦getæ“ä½œçš„ä¾èµ–æ”¶é›†ã€‚

å…ˆçœ‹çœ‹æˆ‘ä»¬çš„`readonly`æµ‹è¯•ç”¨ä¾‹ï¼š
```typescript
describe('readonly', () => {
  it('readonly not set', () => {
    let original = {
      foo: {
        fuck: {
          name: "i don't care",
        },
      },
      arr: [{color: '#fff'}]
    }
    let warper = readonly(original)
    expect(warper).not.toBe(original)
    expect(warper.foo.fuck.name).toBe("i don't care")
  })
  it('warning when it be call set operation', () => {
    let original = {
      username: 'ghx',
    }
    let readonlyObj = readonly(original)
    const warn = jest.spyOn(console, 'warn')
    // ç»™readonlyåšsetæ“ä½œï¼Œå°†ä¼šå¾—åˆ°ä¸€ä¸ªwarning
    readonlyObj.username = 'danaizi'
    expect(warn).toHaveBeenCalled()
  })
})
```

å¦‚æœç¡¬è¦ç»™`reactive`çš„ä»£ç†å¯¹è±¡èµ‹å€¼ï¼Œé‚£ä¹ˆå®ƒå°†å¾—åˆ°ä¸€ä¸ªè­¦å‘Š(warn)
```typescript
export function readonly<T>(target: T) {
  return new Proxy(target, {
    get(target, key) {
      let res = Reflect.get(target, key)
      // æ— éœ€ä¾èµ–æ”¶é›†ï¼Œåˆ é™¤äº†track()å‡½æ•°
      return res
    },
    set(target, key, value) {
      // æ— éœ€è§¦å‘ä¾èµ–
      console.warn(`${target} do not set ${String(key)} value ${value}, because it is readonly`)
      return true
    },
  })
}
```
### å¯¹å·²æœ‰ä»£ç çš„é‡æ„
ä¹‹å‰æˆ‘ä»¬å·²ç»å®ç°äº† `reactive` å’Œ `readonly`ï¼Œè¿™æ—¶å€™æˆ‘ä»¬åº”è¯¥åè§‚ä¸€ä¸‹ä»£ç ï¼Œè§‚å¯Ÿä»£ç æœ‰æ²¡æœ‰é‡å¤çš„ä»£ç æ®µæ˜¯éœ€è¦æˆ‘ä»¬å»ä¼˜åŒ–çš„ã€‚ ç›®å‰çš„ä¸è¶³ï¼š`reactive` å’Œ `readonly` éƒ½æœ‰ç›¸ä¼¼çš„å®ç°ï¼Œç›¸åŒçš„ä»£ç æ®µè¾ƒå¤šï¼Œå¯ä»¥æŠ½ç¦»å‡ºæ¥
ç®€è¿°ï¼š
1. `reactive` å’Œ `readonly`çš„ä¼ å…¥ç›¸åŒçš„å…¥å‚`target`
2. `reactive` å’Œ `readonly`éƒ½è¿”å›proxyå¯¹è±¡
3. `reactive` å’Œ `readonly`çš„proxyå¯¹è±¡éƒ½æœ‰getå’Œsetæ–¹æ³•ï¼Œä½†æ˜¯å†…éƒ¨çš„ä»£ç å®ç°æœ‰ç‚¹ä¸åŒ

ä¸ºäº†ç»Ÿä¸€å¤„ç†è¿™äº›ç›¸åŒçš„ä»£ç é€»è¾‘ï¼Œæˆ‘ä»¬ä¸å¦¨æ–°å»ºæ–‡ä»¶`baseHandlers.ts`ä½œä¸º`Proxy`çš„ç¬¬äºŒå…¥å‚handlerçš„å®šä¹‰æ–‡ä»¶ï¼Œåˆå› ä¸ºè¿”å›çš„éƒ½æ˜¯`new Proxy()`å¯¹è±¡ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ª`createReactiveObject`å‡½æ•°ï¼Œç”¨äºç»Ÿä¸€åˆ›å»ºproxyå¯¹è±¡ï¼Œå¢å¼ºä»£ç çš„å¯è¯»æ€§ã€‚
```typescript
// In baseHandlers.ts
export function createReactiveObject<T extends object>(target: T, handlers: ProxyHandler<T>) {
  return new Proxy(target, handlers)
}
```
handlersé€šè¿‡ä½œä¸ºå¯¹è±¡ç»Ÿä¸€ä¼ å…¥`createReactiveObject`ï¼Œè¿™æ ·å°±å¯ä»¥ç»Ÿä¸€å¤„ç†`reactive`å’Œ`readonly`çš„ä¸åŒé€»è¾‘ã€‚
```typescript
export const mutableHandlers: ProxyHandler<object> = {
  get: function(target: T, key: string | symbol) {
    let res = Reflect.get(target, key)
    // ä¾èµ–æ”¶é›†
    track(target, key as string)
    return res
  },
  set: function(target: T, key: string | symbol, value: any) {
    let success: boolean
    success = Reflect.set(target, key, value)
    // è§¦å‘ä¾èµ–
    trigger(target, key as string)
    return success
  },
}
export const readonlyHandlers: ProxyHandler<object> = {
  get: function(target: T, key: string | symbol) {
    let res = Reflect.get(target, key)
    return res
  },
  set(target, key, value) {
    console.warn(`${target} do not set ${String(key)} value ${value}, because it is readonly`)
    return true
  },
}
```
ä»”ç»†è§‚å¯Ÿä¸Šé¢çš„ä»£ç ï¼Œæˆ‘ä»¬éƒ½æœ‰ç›¸åŒçš„setå’Œgetï¼Œå†…éƒ¨åŒæ ·å®ç°äº†å–å€¼æ“ä½œï¼Œä½†æœ‰æ‰€ä¸åŒçš„æ˜¯readonlyçš„setæ“ä½œä¼šæŠ›å‡ºwarnï¼Œè¿™ä¸€ç‚¹æˆ‘ä»¬å¯ä»¥ä¸éœ€è¦å¤„ç†ã€‚ä¸ºäº†åŒºåˆ†`reactive`å’Œ`readonly`setå’Œgetçš„ä¸åŒé€»è¾‘ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ ‡è¯†`isReadonly`

æŠ½ç¦»ç›¸åŒçš„setå’Œgetä»£ç ï¼Œæˆ‘ä»¬å¤–éƒ¨éœ€è¦å®šä¹‰setå’Œgetå‡½æ•°ï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦ä¼ å…¥ä¸€ä¸ªæ ‡è¯†`isReadonly`åŒºåˆ†è¯¥å‡½æ•°åˆ°åº•æ˜¯`reactive`çš„ä»£ç é€»è¾‘è¿˜æ˜¯`readonly`çš„ä»£ç é€»è¾‘ï¼ŒåŒæ—¶ä¸èƒ½ä¸º`set`å’Œ`get`æ–°å¢å…¶ä»–çš„å…¥å‚ä»¥é˜²ç ´åä»£ç çš„å¯è¯»æ€§ã€‚
æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªé«˜é˜¶å‡½æ•°ï¼Œè¯¥å‡½æ•°è¿”å›setå’Œsetå‡½æ•°ï¼Œå…¥å‚æ˜¯`isReadonly`ã€‚
```typescript
// In baseHandlers.ts
// é«˜é˜¶å‡½æ•°ï¼ŒisReadonlyé»˜è®¤ä¸ºfalse
export function createGetter<T extends object>(isReadonly = false) {
  return function get(target: T, key: string | symbol) {
    
    let res = Reflect.get(target, key)
    
    if (!isReadonly) {
      // åˆ¤æ–­æ˜¯å¦readonly
      // ä¾èµ–æ”¶é›†
      track(target, key as string)
    }
    return res
  }
}
export function createSetter<T extends object>() {
  return function set(target: T, key: string | symbol, value: any) {
    let success: boolean
    success = Reflect.set(target, key, value)
    // è§¦å‘ä¾èµ–
    trigger(target, key as string)
    return success
  }
}
```
ä¹‹åå®šä¹‰ä¸åŒçš„handlerså¯¹è±¡ï¼Œç”¨äºä½œä¸ºå…¥å‚ä¼ å…¥`createReactiveObject`
```typescript
// reactiveçš„handlers
export const mutableHandlers: ProxyHandler<object> = {
  get: createGetter(),
  set: createSetter(),
}
// readonlyçš„handlers
export const readonlyHandlers: ProxyHandler<object> = {
  get: createGetter(true),
  set(target, key, value) {
    console.warn(`${target} do not set ${String(key)} value ${value}, because it is readonly`)
    return true
  },
}
```
## å®ç° isReactive



## å®ç° isReadonly


## å®Œå–„ readonly å’Œ reactive



### é‡åˆ°åµŒå¥—çš„å¯¹è±¡æ—¶çš„å¤„ç†æ–¹å¼

### åæ€
isRef

## ä¼˜åŒ–ç‚¹

## æ€»ç»“



## æœ€å@æ„Ÿè°¢é˜…è¯»

## å®Œæ•´ä»£ç 

```typescript
// In share/index.ts
// åˆ¤æ–­valueæ˜¯å¦objectæˆ–è€…array
export const isObject = (value: unknown) => {
  return value !== null && typeof value === 'object'
}

```
```typescript
// In reactive.ts

import { createReactiveObject, mutableHandlers, readonlyHandlers } from './baseHandlers'

export enum ReactiveFlags {
  IS_REACTIVE = '__v_isReactive',
  IS_READONLY = '__v_isReadonly'
}
// ç»™valueåšç±»å‹æ‰¹æ³¨ï¼Œè®©valueæœ‰ä»¥ä¸‹å‡ ä¸ªå¯é€‰å±æ€§,ä¸ç„¶è¯¥æ­»çš„valueé£˜çº¢ --isReactiveå‡½æ•°å’ŒisReadonlyå‡½æ•°  è¯´çš„å°±æ˜¯ä½ ä»¬
export interface Target {
  [ReactiveFlags.IS_REACTIVE]?: boolean;
  [ReactiveFlags.IS_READONLY]?: boolean;
}

export function reactive<T extends object>(target: T) {
  return createReactiveObject<T>(target, mutableHandlers)
}
// å…¶å®å°±æ˜¯ä¸€ä¸ªæ²¡æœ‰setæ“ä½œçš„reactive
export function readonly<T extends object>(target: T) {
  return createReactiveObject<T>(target, readonlyHandlers)
}

export function isReactive(value: unknown) {
  // targetæ²¡æœ‰__v_isReactiveè¿™ä¸ªå±æ€§ï¼Œä¸ºä»€ä¹ˆè¿˜è¦å†™target['__v_isReactive']å‘¢ï¼Ÿå› ä¸ºè¿™æ ·å°±ä¼šè§¦å‘proxyçš„getæ“ä½œï¼Œ
  // é€šè¿‡åˆ¤æ–­createGetterä¼ å…¥çš„å‚æ•°isReadonlyæ˜¯å¦ä¸ºtrueï¼Œå¦åˆ™isReactiveä¸ºtrue
  // ä¼˜åŒ–ç‚¹ï¼šç”¨enumç®¡ç†çŠ¶æ€ï¼Œå¢å¼ºä»£ç å¯è¯»æ€§
  return !!(value as Target)[ReactiveFlags.IS_REACTIVE]
}
export function isReadonly(value: unknown){
  // åŒä¸Š
  return !!(value as Target)[ReactiveFlags.IS_READONLY]
}

```
```typescript
// In baseHandlers.ts

import { track, trigger } from './effect'
import { reactive, ReactiveFlags, readonly } from './reactive'
import { isObject } from '../shared'
// æ­¤å¤„è°ƒç”¨ä¸€æ¬¡createSetterå’Œgetterï¼Œä¸ºäº†ä¸åœ¨æ¯æ¬¡ä½¿ç”¨mutableHandlersçš„æ—¶å€™é‡å¤è°ƒç”¨
const get = createGetter()
const set = createSetter()
const readonlyGet = createGetter(true)

// é«˜é˜¶å‡½æ•°ï¼Œ
export function createGetter<T extends object>(isReadonly = false) {
  return function get(target: T, key: string | symbol) {
    // isReactiveå’ŒisReadonly éƒ½æ˜¯æ ¹æ®ä¼ å…¥çš„å‚æ•° `isReadonly`æ¥å†³å®šæ˜¯å¦è¿”å›true | falseçš„
    if (key === ReactiveFlags.IS_REACTIVE) {
      return !isReadonly
    } else if (key === ReactiveFlags.IS_READONLY) {
      return isReadonly
    }
    let res = Reflect.get(target, key)
    // ä¹‹å‰éƒ½æ˜¯åªå®ç°è¡¨é¢ä¸€å±‚çš„reactiveï¼Œæˆ‘ä»¬ç°åœ¨å®ç°åµŒå¥—å¯¹è±¡çš„reactive
    if(isObject(res)){
      return isReadonly ? readonly(res) : reactive(res)
    }
    if (!isReadonly) {
      // åˆ¤æ–­æ˜¯å¦readonly
      // ä¾èµ–æ”¶é›†
      track(target, key as string)
    }
    return res
  }
}
export function createSetter<T extends object>() {
  return function set(target: T, key: string | symbol, value: any) {
    let success: boolean
    success = Reflect.set(target, key, value)
    // è§¦å‘ä¾èµ–
    trigger(target, key as string)
    return success
  }
}

export const mutableHandlers: ProxyHandler<object> = {
  get,
  set,
}
export const readonlyHandlers: ProxyHandler<object> = {
  get: readonlyGet,
  set(target, key, value) {
    console.warn(`${target} do not set ${String(key)} value ${value}, because it is readonly`)
    return true
  },
}
export function createReactiveObject<T extends object>(target: T, handlers: ProxyHandler<T>) {
  return new Proxy(target, handlers)
}

```
```typescript
// In readonly.spec.ts
import { readonly, isReadonly } from '../reactive'
describe('readonly', () => {
  it('readonly not set', () => {
    let original = {
      foo: {
        fuck: {
          name: 'what',
        },
      },
      arr: [{color: '#fff'}]
    }
    let warper = readonly(original)
    expect(warper).not.toBe(original)
    expect(isReadonly(warper)).toBe(true)
    expect(isReadonly(original)).toBe(false)
    // æµ‹è¯•åµŒå¥—å¯¹è±¡çš„reactiveçŠ¶æ€
    expect(isReadonly(warper.foo.fuck)).toBe(true)
    // expect(isReadonly(warper.foo.fuck.name)).toBe(true) // å› ä¸ºnameæ˜¯ä¸€ä¸ªåŸºæœ¬ç±»å‹æ‰€ä»¥isObjectä¼šæ˜¯falseï¼Œæš‚æ—¶å¯¹nameç”Ÿæˆä¸äº†readonlyï¼Œæ¶‰åŠåˆ°å¾€åçš„çŸ¥è¯†ç‚¹ isRef
    expect(isReadonly(warper.arr)).toBe(true)
    expect(isReadonly(warper.arr[0])).toBe(true)
    expect(warper.foo.fuck.name).toBe('what')
  })
  it('warning when it be call set operation', () => {
    let original = {
      username: 'ghx',
    }
    let readonlyObj = readonly(original)
    const warn = jest.spyOn(console, 'warn')
    readonlyObj.username = 'danaizi'
    expect(warn).toHaveBeenCalled()
  })
})

```
```typescript
// In reactice.spec.ts

import { reactive, isReactive } from '../reactive'

describe('reactive', () => {
  it('reactive test', () => {
    let original = { num: 1 }
    let count = reactive(original)
    expect(original).not.toBe(count)
    expect(count.num).toEqual(1)
    expect(isReactive(original)).toBe(false)
    expect(isReactive(count)).toBe(true)
  })
  it('nested reactive',()=>{
    let original = {
      foo: {
        name: 'ghx'
      },
      arr: [{age: 23}]
    }
    const nested = reactive(original)
    expect(isReactive(nested.foo)).toBe(true)
    expect(isReactive(nested.arr)).toBe(true)
    expect(isReactive(nested.arr[0])).toBe(true)
    expect(isReactive(nested.foo)).toBe(true)
    // expect(isReactive(nested.foo.name)).toBe(true) // æ¶‰åŠåˆ°å¾€åçš„çŸ¥è¯†ç‚¹ isRef
    
  })
})

```
